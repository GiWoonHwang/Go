/*
Go Slice는 내부적으로 배열에 기초하여 만들어 졌지만 배열의 이런 제약점들을 넘어 개발자에게 편리하고 유용한 기능들을 제공한다. 슬라이스는 배열과 달리 고정된 크기를 미리 지정하지 않을 수 있고, 차후 그 크기를 동적으로 변경할 수도 있고, 또한 부분 배열을 발췌할 수도 있다.
Go Slice 선언은 배열을 선언하듯이 "var v []T" 처럼 하는데 배열과 달리 크기는 지정하지 않는다. 예를 들어, 정수형 Slice 변수 a를 선언하기 위해서 "var a []int" 처럼 선언할 수 있다.
*/

package main

import "fmt"

func main() {
	var a []int        //슬라이스 변수 선언
	a = []int{1, 2, 3} //슬라이스에 리터럴값 지정
	a[1] = 10
	fmt.Println(a) // [1, 10, 3]출력
}

/*
Go에서 Slice를 생성하는 또 다른 방법으로 Go의 내장함수 make() 함수를 이용할 수 있다. make() 함수로 슬라이스를 생성하면, 개발자가 슬라이스의 길이(Length)와 용량(Capacity)을 임의로 지정할 수 있는 장점이 있다. make() 함수의 첫번째 파라미터에 생성할 슬라이스 타입을 지정하고,
두번째는 Length (슬라이스의 길이), 그리고 세번째는 Capacity (내부 배열의 최대 길이)를 지정하면, 모든 요소가 Zero value인 슬라이스를 만들게 된다. 여기서 만약 세번째 Capacity 파라미터를 생략하면 Capacity는 Length와 같은 값을 갖는다.
그리고 슬라이스의 길이 및 용량은 내장함수 len(), cap()을 써서 확인할 수 있다.
*/

func test() {
	// 125인승 버스 == 용량, 30명 탑슴 == 길이
	s := make([]int, 5)
}

// 슬라이스에 별도의 길이와 용량을 지정하지 않으면, 기본적으로 길이와 용량이 0 인 슬라이스를 만드는데, 이를 Nil Slice 라 하고, nil 과 비교하면 참을 리턴한다.
func test2() {
	var s []int
	if s == nil {
		println("Nill Slice")
	}
	println(len(s), cap(s)) // 모두 0
}

/*
슬라이스에서 일부를 발췌하여 부분 슬라이스를 만들 수 있다. 부분 슬라이스는 "슬라이스[처음인덱스:마지막인덱스]" 형식으로 만드는데, 예를 들어 슬라이스 s 에 대해 인덱스 2부터 4까지 데이타를 갖는 부분 슬라이스를 만드려면, s[2:5]와 같이 표현한다. 여기서 [2:4]가 아니라 [2:5]으로 쓰는데, 마지막인덱스는 원하는 인덱스+1 을 사용한다. 즉, 처음인덱스는 Inclusive 이며, 마지막인덱스는 Exclusive이다 (주: Python과 동일).
*/
func test3() {
	s := []int{0, 1, 2, 3, 5}
	s = s[2:5]
	fmt.println(s)
}

// 새로운 요소를 추가하기 위해서는 Go 내장함수인 append()를 사용한다. append()의 첫 파라미터는 슬라이스 객체이고, 두번째는 추가할 요소의 값이다. 또한 여러 개의 요소 값들을 한꺼번에 추가하기 위해서는 append() 두번째 파라미터 뒤에 계속하여 값을 추가할 수 있다.

func test4() {
	s := []int{0, 1}
	s = append(s, 2)
	s = append(s, 1, 2, 3, 5, 6)

	fmt.Println(s)
}

/*
슬라이스에 저장된 값을 복사할 때 단순히 새로운 변수에 대입해서 사용하게 되면 메모리에 참조하고 있는 포인터까지 그대로 복사해 오기 때문에, 기존변수, 복사한 변수 값이 모두 변경되어 버린다
따라서 copy를 이용한 복사를 이용해 이러한 문제점을 피해자
*/
func test5() {
	source := []int{0, 1, 2}
	target := make([]int, len(source), cap(source)*2)
	copy(target, source)
	fmt.Println(target)               // [0 1 2 ] 출력
	println(len(target), cap(target)) // 3, 6 출력
}
